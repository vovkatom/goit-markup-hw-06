/*! Прикол */
/*? Прикол */
/** Прикол */
/* Прикол */

# goit-markup-hw-03

https://vovkatom.github.io/goit-markup-hw-03/

Властивість border — додає рамку;

padding — встановлює внутрішні поля;

margin — задає зовнішні відступи. Маржин елемента необхідно переглядати за допомогою інструментів розробника, адже візуально на сторінці вони не виділяються. Колапсування вертикальних маржинів
Вертикальні маржини сусідніх блокових елементів не складаються. Якщо є два елемента з різними значеннями властивості margin, вибирається найбільший margin із двох. Колапсування маржинів відбувається лише для блокових елементів. Задамо верхньому блоку нижній margin 20px, а нижньому — верхній margin 40px. Через схлопування, відстань між ними буде 40px, тому що вибирається більший маржин із двох.

Якщо значення для margin і padding не задані, використовуються значення за замовчуванням із таблиці стилів браузера.
В іншому разі ваші стилі мають вищу специфічність і перебивають стилі від браузера.
Для більшості елементів задається тільки ширина. Вказувати одночасно width і height варто тільки для декоративних елементів з фіксованим розміром, наприклад іконкам.

<!-- box-sizing -->
Властивість box-sizing визначає тип блокової моделі елемента – формулу (алгоритм) розрахунку його розмірів.
box-sizing: content-box | border-box | inherit
content-box — властивості width і height задають ширину і висоту області вмісту і не включають розміри полів (padding), рамок (border) і відступів (margin). Це значення за замовчуванням.
border-box — властивості width і height задають кінцевий розмір елемента і включають значення полів (padding), рамок (border), але не зовнішніх відступів (margin).
inherit — успадковує значення блокової моделі батьківського елемента.
Зовнішні відступи (margin) у розрахунку ширини чи висоти елемента не враховуються.

<!-- Значення content-box -->
Цей тип блокової моделі використовується в таблиці стилів браузера за замовчуванням. Розрахунок кінцевих розмірів елемента складніший, бо властивості width і height задають не загальний розмір елемента, а тільки висоту і ширину його області вмісту.
Ширина = width + padding-left + padding-right + border-left + border-right
Висота = height + padding-top + padding-bottom + border-top + border-bottom
Задавши елементу width 150px, padding 30px та border 5px, отримаємо сумарну ширину 220px.

<!-- Значення border-box -->
У цій блоковій моделі властивості width і height задають кінцеві розміри елемента, а не його області вмісту. Контент автоматично «стискається» так, щоб всередині контейнера ще вмістилися padding і border .
Формули розрахунку кінцевої ширини й висоти блоку при значенні border-box.
Ширина = width
Висота = height
Якщо задати властивості box-sizing значення border-box, то тип блокової моделі поточного елемента зміниться.

<!-- Глобальний border-box -->
Стандартом блокової моделі в сучасних проєктах вважається значення border-box. Для того, щоб не задавати властивість box-sizing кожному елементу окремо, на початку файлу стилів використовується наступний CSS-код.
*,
*::before,
*::after {
  box-sizing: border-box;
}
/* Решта коду */
Використовуючи універсальний селектор * (вибирає всі елементи), значення border-box встановлюється для всіх елементів і псевдоелементів ::before та ::after документа (про них дізнаємося пізніше).
У нормалізаторі modern-normalize(https://github.com/sindresorhus/modern-normalize) за умовчанням задано глобальний border-box. Отже, якщо його підключено до проєкту, то у своїх стилях box-sizing можна не вказувати.

<!-- Властивості padding-* -->
Аби задати падінг тільки з однієї чи двох сторін, застосовуються властивості задання padding для кожної сторони окремо. Для явно не зазначених сторін використовуються
значення за замовчуванням з таблиці стилів браузера, а якщо таких немає, вважається, що значення дорівнює 0 .

<!-- Властивість margin -->
Складова властивість margin контролює зовнішні відступи від рамки до сусідніх елементів для всіх сторін елемента. Результат роботи залежить від того, скільки значень властивості вказано.
/* Однакові відступи по 20px з усіх боків */
margin: 20px;
/* Відступ зверху та знизу по 10px, зліва та праворуч по 20px */
margin: 10px 20px;
/* Відступ зверху 10px, ліворуч і праворуч по 20px, знизу 5px */
margin: 10px 20px 5px;
/* Відступ зверху 10px, праворуч 15px, знизу 20px, зліва 25px */
margin: 10px 15px 20px 25px;

<!-- Властивості margin-* -->
Як і з падінгами, трапляються випадки, коли потрібно задати маржин ****тільки з однієї, двох або трьох сторін. Для явно не визначених сторін застосовуються значення за замовчуванням або, якщо таких немає, вважається, що значення дорівнює 0.
margin-top: 20px;
margin-right: 10px;
margin-bottom: 15px;
margin-left: 30px;

<!-- padding або margin? -->
Дуже важливо не плутати padding і margin. Різниця в тому, що:
padding відокремлює вміст від рамки елемента.
margin створює проміжки між сусідніми елементами.
Якщо вам важко запам’ятати, де використовувати падінг, а де маржин, під час верстки задавайте всім елементам колір фону, адже він поширюється тільки на вміст, падінг і рамку, але не на маржини. Так буде візуально зрозуміло. Після того, як верстка виконана, видаліть із CSS-правил допоміжні властивості кольору фона.

<!-- Глобальне скидання стилів -->
Найчастіше значення margin і padding sз таблиці стилів браузера не збігаються з дизайном, а деякі з них зовсім не потрібні. Наприклад, заголовки та абзаци зазвичай потребують лише нижнього чи верхнього маржину, а за замовчуванням задані обидва. У списках стандартний padding і margin здебільшого не потрібен. Так, якщо прибрати стандартний padding, то пропадуть маркери списку. Але в більшості випадків за дизайном вони не потрібні, і ми їх скидаємо властивістю list-style-type:disc
При написанні стилів доведеться в кожному CSS-правилі для цих елементів додавати скидання чи перевизначення значень.
Як вирішити цю проблему?
Можна винести скидання стандартних значень таблиці стилів браузера у глобальні стилі, використовуючи селектор тега. Це скоротить кількість повторень коду з обнуленням значень. Після цього у правилах потрібно лише вказати значення з дизайну без коду скидання непотрібних значень.
h1, h2, h3, h4, h5, h6, p {
	margin-top: 0;
	margin-bottom: 0;
}

<!-- Маржин елемента body -->
За замовчуванням у таблиці стилів браузера для margin елемента body задано значення 8px з усіх боків. Це зроблено, щоб вміст веб-сторінок без додаткового оформлення не щільно прилягав до меж вкладки браузера й читати текст було зручніше..У дизайні сучасних веб-сторінок цей маржин не застосовується, тому його завжди обнуляють у правилі із селектором body. Обнулення маржина body вже є певним «стандартом» сучасної розробки, то ж нормалізатор modern-normalize містить цей крок. Тому, якщо на вашій веб-сторінці застосовується нормалізатор,, обнуляти маржин body у своєму коді не потрібно.

<!-- Властивість border -->
Складова властивість border контролює ширину, стиль і колір рамки елемента. border: ширина стиль колір;
Ширина рамки визначається в пікселях.
Стиль — одне значення з набору можливих значень, найпоширенішими значеннями є solid, dashed і dotted.
Колір задається в будь-якому форматі, зазвичай HEX

<!-- Властивості border-* -->
Також є властивості, що окремо задають значення рамки. Їх можна застосовувати в якості альтернативи властивості border, або щоб при зміні лиш одного значення рамки не дублювати інші властивості.
border-width: значення;
border-style: значення;
border-color: значення;

<!-- Індивідуальні рамки -->
Рамці можна задати індивідуальні стилі з кожного боку елемента. Звісно ж, елемент з різнокольоровою рамкою та ще й з кількома стилями — це зовсім не стандартна практика. Зазвичай так не роблять.
А ось задати рамку тільки з однієї сторони елемента — це саме той випадок, в якому ці властивості стануть у нагоді.
border-top: ширина стиль колір;
border-right: ширина стиль колір;
border-bottom: ширина стиль колір;
border-left: ширина стиль колір;

<!-- Заокруглена рамка -->
всі кути рамки, застосовується властивість border-radius. Значення можуть бути як абсолютні (px), так і відносні (%). Якщо квадратному елементу задати радіус 50%, це перетворить його на коло.
/* верхній лівий кут */
border-top-left-radius: значення;
/* верхній правий кут */
border-top-right-radius: значення;
/* нижній правий кут */
border-bottom-right-radius: значення;
/* нижній лівий кут */
border-bottom-left-radius: значення;

<!-- Заокруглене зображення -->
overflow: hidden;

<!-- Властивість overflow -->
Розміри елемента: Визначаються контентом усередині або Задаються явно.
Що відбувається, коли змінюється вміст усередині елемента?
У першому випадку, коли висоту елемента не встановлено явно, висота збільшуватиметься, доки в елементі не поміститься весь контент
У другому випадку ширина та висота вказані явно. Отже, блок не може збільшитися, і вміст його переповнює, тобто виходить за його межі.
Властивість overflow керує поведінкою вмісту елемента, якщо його розмір перевищує припустиму висоту чи ширину.
overflow: visible | hidden | scroll | auto
Також є властивості overflow-x і overflow-y, що контролюють переповнення тільки у відповідній площині.

<!-- Властивість overflow: visible; -->
Якщо не вказати властивість overflow, то за замовчуванням встановлюється значення visible Отже, при переповненні, вміст буде відображатися за межами блоку.
Зверни увагу, у прикладі вище є текст, що переповнює блок. Але цей текст не впливає на сусідній елемент — кнопку. Отже, видимий контент, що переповнює блок, не впливає на геометрію сусідніх елементів.

<!-- Властивість overflow: hidden; -->
Протилежне значення — hidden. У цьому випадку будь-який вміст, що виходить за межі елемента, не відображається. Така поведінка є зручною для використання з декоративними ефектами. 
Пам'ятайте, що в цьому випадку переповнювальний контент недоступний та прихований від користувача. Саме тому, ми ніколи не задаємо фіксовану висоту текстовим блокам.

<!-- Властивість overflow: scroll; -->
При значенні scroll, контент, що переповнює блок, буде прихований. Для перегляду прихованого контенту з'являться скроллбари.
Зверни увагу, що показані обидва скроллбари (горизонтальний і вертикальний) при тому, що потрібен тільки один.

<!-- Властивість overflow: auto; -->
Значення auto схоже на значення scroll. Є й відмінність — при значенні auto показуються тільки ті скроллбари, які дійсно необхідні.

<!-- Властивість display -->
У таблиці стилів браузера кожного елемента встановлено його тип, що визначає його поведінку. Найпоширенішими є блокові (block) та рядкові (inline) елементи. Крім цього, є ще їхній гібрид - рядково-блокові (inline-block).
Рядкові елементи призначені для виділення та оформлення текстового контенту. Наприклад посилань кнопок, зображень тощо.
Блокові елементи використовуються для розмітки текстових контейнерів (заголовків, списків, абзаців) і великих смислових розділів (секцій, шапки, підвалу).
Іноді необхідно, щоб рядковий елемент поводився, як блоковий і навпаки. У цьому випадку, значення властивості display можна за необхідності міняти на будь-яке інше.

<!-- Блокові елементи -->
Блокові елементи можуть бути візуально представлені, як прямокутні області, що йдуть одна за одною зверху вниз. Вони займають всю доступну ширину рядка всередині батьківського елемента. Їхня висота визначається вмістом, якщо явно не задана у властивості height. Вони завжди починаються з нового рядка, тому кілька сусідніх блокових елементів розташовані вертикально один під одним. Їм можна задавати будь-які властивості геометрії елемента: ширину, висоту, падінги, рамки та маржини.

<!-- Фіксована ширина -->
Навіть якщо ширину блокових елементів задано явно, елементи все одно розташовуватимуться вертикально один під одним. Усе вільне місце в рядку за замовчуванням займає автоматичний правий відступ (margin-right) елемента. 

<!-- Випадання вертикальних маржинів -->
Вертикальний маржин вкладеного блоку випадає з батьківського та відштовхує обидва блока (батьківський та вкладений) від сусіда або верха сторінки. Якщо у батьківського елемента також був заданий верхній маржин, то застосується те значення маржину, що є більшим. Верхні та нижні маржини на стику з батьківьским блоком ніби пробивають його й випадають назовні. Це одна з найчастіших помилок верстки. Робіть маржини лише між двома сусідніми елементами.

<!-- Горизонтальне центрування блокових елементів -->
Блоковий елемент можна горизонтально відцентрувати всередині батьківського елемента, якщо його ширина більша за ширину цього елемента. Тобто, блоковому елементу задано фіксовану ширину. Для цього використовується особливість автоматичних горизонтальних маржинів. За замовчуванням блоковий елемент має автоматичний правий маржин, який займає все вільне місце в рядку. Якщо задати автоматичні лівий і правий маржини, вільний простір розподіляється між ними, і блочний елемент центрується. Спроти можна margin: 0 auto;

<!-- Рядкові елементи (inline) -->
Рядкові елементи візуально розташовуються один за одним за всією довжиною рядка. Коли місця вже не вистачає, ці елементи переносяться на наступний рядок і заповнюють його.
Для рядкових елементів задається властивість display: inline. Їхня ширина та висота залежать тільки від вмісту, явно задати їх не можна. Тобто властивості width і height не мають жодного ефекту.
Вони розташовуються в рядку, доки в ньому є достатньо місця, після чого нові елементи переносяться на наступний рядок. Їм можна задавати лише горизонтальну геометрію: ліві та праві маржини, падінги та рамки. Тобто вони ігнорують значення верхніх і нижніх 'margin', 'padding' і border. 
Верхні та нижні падінги, а також рамки рядкового елемента працюють дуже дивно — не збільшують розмір блоку, але візуально відображаються. Це особливість відображення у браузері, вони ніяк не впливають на геометрію сусідніх елементів і тому не використовуються 🤷‍♂️.

<!-- Рядково-блокові елементи (inline-block) -->
гібрид між блочними та рядковими елементами, який взяв корисне від обох.
Для них задана властивість display: inline-block. Їх ширина і висота залежать від вмісту, але можна явно задати властивості width і height. Вони розташовуються в рядку доти, поки в ньому є достатньо місця, після чого нові переносяться на наступний рядок. Їм можна задавати будь-які властивості геометрії елемента: ширину, висоту, поля, рамки та відступи.
Рядково-блокові елементи використовуються в тих випадках, коли рядковим елементам потрібно додати декоративні ефекти.
Приклади таких задач: Задати для посилання вертикальні падінги, маржини або ширину з висотою, візуально зробивши з неї кнопку; Перетворити span> на іконку з фіксованими розмірами.

<!-- Проміжок рядкових елементів -->
У рядкових та рядково-блочних елементів є правий проміжок. Це не margin або padding, а буквально порожнє місце. Це особливість того, як браузер розташовує рядковий контент у рядку.
Величина цього проміжку визначається: розміром тексту найближчого батьківського елемента з явно визначеним значенням
Або якщо такого батьківського елемента немає, використовується розмір шрифту від браузера за замовчуванням - 16px.
Тому у кнопок, посилань, зображень, спанів і інших рядкових елементів за умовчанням буде проміжок 4px — 1/4 розміру шрифту найближчого батьківського елемента.

<!-- Приховані елементи -->
Значення display: none дозволяє повністю приховати елемент, звільнивши його простір для інших. Такий елемент вилучається з потоку документа, візуально приховується й відсутній у розкладці сторінки.

<!-- Нижній проміжок рядкового елемента -->
Зображення — це рядковий елемент. Отже, між двома зображеннями чи зображенням і іншим рядковим елементом буде відстань по горизонталі. Це ми вже знаємо і скоро навчимося обходити.
Зображення — особливий елемент тому, що в нього крім правого зазору є ще нижній зазор рядкового елемента, за розміром такий самий, як і горизонтальний.
На практиці цей проміжок ніколи не потрібний й тільки заважає. Його дуже просто прибрати. Достатньо зробити зображення блоковим елементом!

<!-- Прибираємо нижній проміжок для всього проєкта -->
Аби не дублювати зміну типу елемента для кожного зображення та раз і назавжди прибрати нижній пргоміжок, задамо глобальні стилі тегу img, зробивши його блоковим. Це вирішує проблему.. Та й взагалі, на практиці, при роботі із зображеннями їх завжди роблять блоковими.
img {
	display: block;
}

<!-- Гумові зображення -->
Розберемо, що робить властивість max-width: 100%.
За замовчуванням зображення відображається у своєму оригінальному розмірі. Отже, якщо атрибути розміру для тега img не вказані, зображення виходить за рамки батьківського елемента з фіксованою шириною (див. схему нижче). Таке буває, коли ширина зображення не вказується жорстко й залежить від ширини батьківського елемента. Для того, щоб зображення, для якого явно не задано ширину, автоматично підлаштовувалося під ширину батьківського елемента, додаємо йому властивість максимальної ширини max-width; задаємо для цієї властивості значення 100%; всі ці налаштування робимо у глобальних стилях із селектором тега img, щоб застосувати до всіх зображень на сторінці.

<!-- Властивість object-fit -->
Властивість object-fit визначає яким чином вміст елемента img буде вміщатися в контейнер, коли розміри чи пропорції зображення та контейнера не збігаються. Зображення можна обрізати, розтягувати чи масштабувати.
object-fit: fill | contain | cover | scale-down | none
fill — зображення масштабується без збереження пропорцій, щоб повністю заповнити контейнер. Значення за замовчуванням.
contain — зображення масштабується зі збереженням пропорцій, щоб максимально заповнити контейнер.
cover — зображення масштабується зі збереженням пропорцій, щоб повністю заповнити контейнер.
scale-down — буде вибрано значення none або contain, щоб зображення було найменшого розміру. Мета — вмістити все зображення без зміни пропорцій.
none — зберігаються вихідні розміри зображення, задана висота та ширина не мають жодного ефекта.
На практиці найкориснішим значенням є cover , тому що зображення повністю заповнює контейнер за висотою та шириною, при цьому зберігає пропорції. В інших випадках зображення спотворюється чи не заповнює контейнер.

<!-- Розташування зображення в контейнері фіксованого розміру -->
Для того, щоб ця техніка працювала, необхідні два обов'язкові кроки.
<div class="thumb">
  <img src="" alt="" />
</div>
Перший: контейнеру має бути явно задано фіксовану висоту. Ширина може бути за шириною батьківського елемента, як у живому прикладі.
.thumb {
  height: 400px;
  width: 300px;
}
Другий: зображення необхідно «вмістити» в контейнер, задавши img висоту та ширину 100%, і вказати object-fit.
.thumb img {
  height: 100%;
  width: 100%;
	object-fit: cover;
}
Можна не використовувати контейнер, задавши фіксовані розміри самому елементу img, але найчастіше трапляється саме така розмітка. Елемент контейнера використовується для створення анімацій та інших декоративних ефектів, пов'язаних з областю зображення.

Flexbox

Flexible Box Layout (Flexbox) — це CSS-модуль, який визначає набір властивостей для розміщення, вирівнювання та розподілу простору між елементами в контейнері, навіть якщо їх розмір невідомий або динамічний. Основна ідея полягає в тому, щоб розділити елементи на блок-контейнер (flex-контейнер) та його дітей (flex-елементи).

Flexbox-контейнер може:
змінювати ширину і висоту його дітей;
змінювати напрямок розташування його дітей (вирівнювання в колонку або рядок);
змінювати порядок відображення елементів та відстань між ними;
розширювати елементи, щоб оптимально заповнити доступний простір;
стискати елементи, щоб запобігти переповненню.

У flex-контейнері скасовується більшість правил розташування елементів відповідно до їх типу та потоку документа. 
— Елементи втрачають «тип», перестають бути рядковими або блоковими, вони стають flex-елементами.
— Блокові елементи перестають йти вертикально один під одним.
— Маржини елементів на краю батьківського елементу не випадають.
— Вертикальні маржини не схлопуються.
— Працюють автоматичні вертикальні відступи.

<!-- Main axis -->
Main axis — головна вісь flex-контейнера, вздовж якої розміщуються елементи. Напрямок main axis контролюється властивістю flex-direction. Вона може бути:
-горизонтальною
-вертикальною

<!-- Cross axis -->
Cross axis - поперечна вісь, яка завжди перпендикулярна головній осі (main axis). Її напрямок явно не встановлюється, бо
завжди залежить від
-якщо main axis — горизонтальна, cross axis — вертикальна
-якщо main axis — вертикальна, cross axis — горизонтальна

<!-- Початок та кінець flex-контейнера -->
Модель Flexbox має точки "start" та "end" для визначення порядку елементів всередені flex-контейнера.
Осі (main axis, cross axis) визначають лінії вздовж яких розташовуються елементи.
Точки "start" та "end" — це буквально точки початку та кінця на головній або поперечній осі. Саме вони визначають де буде перший, а де останній елемент по осі.
main-start і main-end — елементи в контейнері завжди розташовуються від main-start (початок головної осі) і до main-end (кінець головної осі).
Що ж таке cross-start і cross-end?
cross-start і cross-end - початок і кінець поперечної осі елементів.
Не слід думати, що старт — це завжди вверху ліворуч, а фініш — завжди внизу праворуч. Будь-який порядок елементів можна налаштувати — зліва направо чи справа наліво, зверху вниз чи знизу вверх. Точки start та end прямо залежать від напрямку осей.

Flex-контейнер (далі просто контейнер) — це батьківський елемент групи елементів, який дозволяє змінити порядок розташування елементів усередені. Саме властивості контейнера контролюють: 

напрямок осей,багаторядковість і позиціонування елементів у рядку.

<!-- Властивість display -->
Властивість display створює flex-контейнер: блоковий або рядково-блоковий.
display: flex | inline-flex

<!-- Властивість gap -->
Аби задати проміжок між flex-елементами, використовується властивість flex-контейнера gap. Нехай у нашому дизайні це буде 8px. Для колекції елементів властивість gap замінює зовнішні відступи, щоб не задавати кожному елементу окремо.

<!-- Властивість flex-direction -->
Flexbox — це система розташування елементів в одному напрямку: горизонтально чи вертикально. Властивість flex-direction задає напрямок головної осі, а отже визначає напрямок елементів у контейнері.
flex-direction: row | row-reverse | column | column-reverse
row — вісь починається зліва й закінчується праворуч. Це значення за замовчуванням.
row-reverse — вісь починається праворуч й закінчується ліворуч.  
column — головна вісь стає вертикально, початок зверху та кінець знизу.
column-reverse — головна вісь розташовується вертикально, початок знизу, кінець зверху.
Отже, ця властивість міняє місцями main-start і main-end головної осі. Flex-елементи завжди будуть розміщені вздовж головної осі від початку (main-start) до кінця (main-end).

<!-- Властивість justify-content -->
Властивість justify-content керує позиціонуванням елементів на головній осі, від main-start до main-end.
justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly
flex-start — елементи притискаються до точки main-start головної осі. Це значення за замовчуванням.
flex-end — елементи притискаються до точки main-end головної осі.
center — елементи центруються на осі.
space-between — елементи рівномірно розподіляються на головній осі. Перший елемент встановлюється на початок осі, а останній на кінець.
space-around — елементи розподіляються рівномірно, але лівий та правий елементи розташовані на відстані від рамок контейнера на половину проміжку між іншими елементами.
space-evenly — елементи розподіляються так, що відстань між елементами та від крайніх елементів до меж контейнера однакова.
Властивість justify-content ****має й інші значення, але вони не підтримуються деякими браузерами або працюють нестабільно між різними браузерами.

<!-- Властивість align-items -->
Властивість align-items керує розташуванням елементів вздовж поперечної осі cross axis. Це аналог justify-content тільки для іншої осі.
align-items: stretch | flex-start | flex-end | center | baseline
stretch — елементи розтягуються по всій довжині осі cross axis. Це значення за замовчуванням.
flex-start — елементи притискаються до точки cross start.
flex-end — елементи притискаються до точки cross end.
center — елементи центруються по осі cross axis.
baseline — елементи вирівнюються по базовій лінії їхнього текстового вмісту.
Властивість align-items має й інші значення, але вони не підтримуються деякими браузерами чи працюють нестабільно між різними браузерами.

<!-- Властивість flex-wrap -->
За замовчуванням display: flex створює однорядковий контейнер, елементи розміщуються на одному рядку й за потреби стискаються.
Властивість flex-wrap дозволяє перетворити однорядковий контейнер на багаторядковий. Елементи будуть додаватися в рядок, доки в ньому буде місце, після чого буде автоматично створено ще один рядок.
Властивість flex-wrap має такі значення:
flex-wrap: nowrap | wrap | wrap-reverse
nowrap — усі елементи будуть на одному рядку. Це значення за замовчуванням.
wrap — дозволяє елементам перестрибувати на інші рядки, які за замовчуванням розташовуються зверху вниз (уздовж cross axis).
wrap-reverse — дозволяє елементам перестрибувати на інші рядки, які розташовуються знизу вгору (уздовж cross axis).

<!-- Сітка елементів -->
Багаторядковий flex-контейнер дозволяє зробити «сітку» елементів, наприклад карток продуктів у інтернет-магазині, прев'ю статей у блозі, галерею зображень тощо.
Покроково розберемо техніку створення "сіток".

Перше, що необхідно зробити, — перетворити ul.card-set на flex-контейнер і зробити його багаторядковим.
.card-set {
  display: flex;
  flex-wrap: wrap;
}

Далі використовуємо властивість gap, аби задати проміжок між стовпцями та рядками сітки. Нехай у нашому уявному макеті це 10px.
.card-set {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}
Властивість gap комбінує в собі значення властивостей row-gap і column-gap, які дозволяють окремо задати розміри проміжків між рядками та стовпцями сітки. Використовуйте gap, коли проміжки однакові. В іншому разі підійдуть row-gap і column-gap.

Останній крок — задати розмір flex-елементів li.item. Ширина вказується у відсотках від загальної ширини батьківського елемента (100%) за такою формулою.
100% - кількість_проміжків_у_рядку * значення_одного_проміжку) / кількість_елементів_у_рядку
Кількість проміжків між елементами в рядку завжди на одиницю менша за кількість елементів. У нашій сітці три елементи в рядок, отже в одному рядку є два проміжки по 10px.
.item {
  width: calc((100% - 20px) / 3);
}

CSS-функція calc() приймає як параметр математичний вираз, результат обчислення якого можна використовувати як значення CSS-властивості. Вираз може містити оператори +, -, *, / з використанням стандартних правил пріоритету.

Чому не використовувати фіксовані значення?
Ширина елемента у відсотках — це масштабоване рішення, оскільки розміри елементів не потрібно буде перераховувати заново при зміні ширини контейнера або проміжку між ними.

<!-- Властивість align-contentЄ                                   в мене інсайдерська інфа! Знайомий розробник розповів, що на співбесідах люблять запитувати. Цікаво? -->
Керує вирівнюванням усіх рядків багаторядкового контейнера уздовж cross axis, якщо є вільне місце. Аналогічно тому, як align-items вирівнює елементи в кожному рядку. Ця властивість не діє, коли є лише один рядок елементів або в контейнері немає вільного місця за вертикаллю (явно не задана висота більше, ніж контент).
align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch
stretch — рядки рівномірно розтягуються, щоб зайняти все місце. Значення за замовчуванням.
flex-start — рядки притискаються до старту cross axis.
flex-end — рядки притискаються до кінця cross axis.
center — рядки центруються на осі cross axis.
Значення space-between, space-around і space-evenly працюють аналогічно властивості justify-content, тільки для рядків, і використовуються рідко.

<!-- Властивість flex-basis -->
Властивість flex-basis визначає початковий розмір flex-елемента у flex-контейнері.
Початковий розмір — це розмір до застосування властивостей flex-grow і flex-shrink, які також впливатимуть на розмір елементів відносно один одного. Розберемо їх трохи пізніше.
Значенням властивості flex-basis може бути будь-яка валідна величина: px або %. Для flex-елементів ця властивість має таку саму функцію, що і властивість width. Але на практиці використовується або width, або flex-basis.
flex-basis: auto | значення
Якщо застосовано обидві властивості, flex-basis і width, то властивість width ігнорується.
Властивість flex-basis може визначати висоту, а не ширину елемента. Це відбувається, коли напрямок головної осі вертикальний.
Властивості min-width і max-width працюють, як обмежувачі розміру елемента, навіть якщо у нього вказано flex-basis.
Властивість flex-basis — це не фінальний розмір елемента, а розмір до розподілу вільного простору, який регулюється властивостями flex-grow і flex-shrink.

<!-- Властивість flex-grow -->
Властивість flex-grow — визначає здатність елемента займати більше місця (рости), ніж початковий розмір. Значення визначається як пропорція (частка) вільного місця в контейнері.
flex-grow: частка
За замовчуванням у всіх елементів встановлено значення 0. Тобто за замовчуванням елементи не намагаються зайняти додаткове вільне місце, навіть якщо таке є. Негативні значення задавати не можна.
Важливо не те, яке значення flex-grow елемента саме по собі, а те, яке воно по відношенню до інших елементів.
Якщо ми встановимо для кожного елемента значення flex-grow: 1, а потім змінимо flex-grow для третього елемента, то побачимо зміни: він займе у 2, 3 та 6 разів більше місця у рядку, ніж інші елементи.
Тобто властивість flex-grow керує пропорціями елементів щодо один одного. Якщо ми встановимо для кожного елемента flex-grow: 4, а для третього елемента значення flex-grow: 12, ми отримаємо той самий результат, що й для значень 1 і 3 відповідно.

<!-- Гумовий контент -->
Типовий випадок використання цієї властивості — сайдбар фіксованої ширини та «гумовий» контент, який займає в рядку все вільне місце, що залишилося.
<div class="container">
  <aside class="sidebar">Sidebar</aside>
  <main class="content">Main content</main>
</div>
Якщо зробити div.container flex-контейнером, то сайдбар займе фіксовану ширину в рядку, а ширина main.content визначатиметься шириною його вмісту.

<!-- Приклеєний футер сторінки -->
Ще один частий випадок застосування властивості flex-grow — необхідність притиснути футер сторінки до її низу, незалежно від обсягу її основного вмісту.
Для реалізації нам знадобиться додатковий елемент-обгортка.
<div class="page-container">
	<header>Page header</header>
	<main>Main content</main>
	<footer>Page footer</footer>
</div>
Перше, що зробимо, — задамо йому мінімальну висоту 100% висоти вкладки браузера на екрані користувача, використовуючи одиниці vh (viewport height — відсоток від висоти області перегляду 5vh = 5% висоти).
.page-container {
	min-height: 100vh;
}
Далі перетворимо його на flex-контейнер і змінимо напрямок головної осі на вертикальний, тобто зверху вниз. Це змусить flex-елементи розташовуватись у стовпчик.
.page-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}
Залишилося задати main властивість flex-grow, щоб дозволити йому займати все вільне місце на головній осі, відсуваючи «футер» у її кінець, тобто вниз.
main {
  flex-grow: 1;
}
Тепер, не залежно від того, скільки вмісту в main, він завжди займає все вільне місце на головній осі, яке залишилося після футера і хедера.

<!-- Властивість flex-shrink -->
На противагу властивості flex-grow, flex-shrink визначає здатність flex-елемента займати менше місця (стискатися), ніж його початковий розмір, тобто впливає на фінальний розмір елемента.
flex-shrink: значення;
Значення задається у вигляді пропорції (частка, фактор).
За замовчуванням у всіх елементів встановлено значення 1, тобто елементи стискатимуться за потреби.Значення 0 заборонить елементу стискатися. Негативні значення задавати не можна.
На практиці flex-shrink зазвичай застосовують, аби заборонити елементу стискатися.

<!-- Властивість align-self -->
Властивість align-self дозволяє елементу змінити своє розташування на cross axis, перевизначивши собі значення властивості align-items від контейнера.
align-self: auto | flex-start | flex-end | center | baseline | stretch
Аналога для main axis немає, й елемент може змістити себе лише з поперечної осі.
Повернімося до прикладу картки із зображенням і текстовим вмістом.
Для вирішення проблеми вертикального розтягування картинки ми використовували властивість контейнера align-items. Властивість align-self дозволяє вирішити цю проблему більш точково, перевизначивши значення align-items тільки для зображення.
.card img {
  align-self: flex-start;
}

<!-- Властивість order -->
За замовчуванням елементи розміщуються в порядку, в якому вони вказані в HTML-файлі. Використовуючи властивість order можна візуально змінити порядок розташування елементів уздовж main axis. При цьому в HTML-коді нічого не зміниться. За замовчуванням всі елементи мають значення 0.
order: позиція;
Ця властивість застосовується вкрай рідко через те, що порушує зв'язок між візуальним порядком елементів і тим, як їх бачить браузер і асистивні технології. Але, знати про таку можливість треба. 
Можливо, саме вам у майбутньому це знадобиться для вирішення завдання.

<!-- Псевдокласи :first-child і :last-child -->
Псевдокласи :first-child і :last-child дозволяють скласти селектор, який застосовується лише до першого чи останнього елемента в колекції сусідніх елементів.
<ul class="list">
  <li class="list-item">HTML</li>
  <li class="list-item">CSS</li>
  <li class="list-item">JavaScript</li>
  <li class="list-item">React</li>
</ul>
.list-item {
  color: blue;
}
.list-item:first-child {
	color: red;
}
.list-item:last-child {
	color: green;
}
Уяви, що за макетом між елементами списку повинен бути маржин (помаранчевий на схемі нижче). Кожному елементу списку потрібно задати нижній або верхній margin.
Але, в цьому разі буде не потрібний верхній маржин у першого чи нижній маржин останнього елемента колекції.
Крайню геометрію, вертикальну чи горизонтальну, необхідно обов'язково очищати, оскільки такі маржини можуть неочевидно випадати чи розширювати батьківський елемент.
.list-item {
  margin-bottom: 12px;
}
.list-item:last-child {
  margin-bottom: 0;
}

<!-- Псевдоклас :not() -->
Псевдоклас :not() дозволяє вибрати всі елементи, що не підходять під критерій.
Критерій вказується у вигляді простого селектора, записаного в дужках. Простий селектор — це універсальний селектор, селектор типу, ідентифікатора, атрибута, класу чи псевдокласу.
:not(selector)
Цей псевдоклас можна застосувати для того, щоб по-іншому вирішити задачу очищення крайнього маржина першого чи останнього елемента.
Замість того, щоб в одному правилі задавати відступ всім, а потім не забути в іншому його обнулити для конкретного елемента, ми в одному правилі задаємо відступ усім елементам, крім одного.
.list-item:not(:last-child) {
  margin-bottom: 20px;
}
Читається як:
застосувати стилі до всіх елементів із класом list-item, які не є останнім елементом у колекції сусідів. Тобто такий селектор застосовується до всіх елементів колекції, крім останнього.

<!-- Парні та непарні елементи -->
Псевдоклас :nth-child(an + b) вибирає елементи в колекції сусідів за номером, вказаним у дужках, за допомогою циклу an + b `, який дозволяє задати правило для послідовності елементів.
a — період циклу. Довільне число.
n — лічильник циклу. Починається з нуля та збільшується на одиницю на кожній ітерації.
b — зміщення. Довільне число.
Наприклад, якщо a = 2, а b = 1, то an + b = 2n +1. Ця формула вибере всі непарні елементи.
# При n = 0
2 * 0 + 1 = 1
# При n = 1
2 * 1 + 1 = 3
# При n = 2
2 * 2 + 1 = 5
# И так далее для n = 3, n = 4 ...
На практиці цей псевдоклас застосовується для вибору всіх парних чи непарних елементів колекції. Наприклад, зробити рядки таблиці різного кольору через один.
Створимо розмітку списку з десяти елементів і змінюватимемо колір їхнього фону.
<ul class="list">
  <li class="list-item">1</li>
  <li class="list-item">2</li>
  <li class="list-item">3</li>
  <li class="list-item">4</li>
  <li class="list-item">5</li>
  <li class="list-item">6</li>
  <li class="list-item">7</li>
  <li class="list-item">8</li>
  <li class="list-item">9</li>
  <li class="list-item">10</li>
</ul>
Для вибору всіх парних елементів можна використовувати формулу 2n або її псевдонім — значення even, зарезервоване слово.
.list-item:nth-child(2n) {
  background-color: orange;
}

/* Аналогічно використовуючи псевдонім */
.list-item:nth-child(even) {
  background-color: orange;
}